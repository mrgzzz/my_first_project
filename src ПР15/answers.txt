1. В чем разница между функциональными и классовыми компонентами в React? Когда следует использовать каждый тип?
Различия:
- Синтаксис: функциональные - функции, классовые - классы ES6
- Состояние: в классовых через this.state, в функциональных через useState
- Жизненный цикл: классовые - методы (componentDidMount и др.), функциональные - хуки (useEffect)
- this: в классовых требуется привязка методов, в функциональных - нет
Когда использовать:
- Функциональные компоненты: для новых проектов, они проще и современнее
- Классовые компоненты: в легационных проектах или когда нужна совместимость

2. Что такое props и state? Как они отличаются и какие правила их использования?
Props (свойства):
- Передаются от родителя к потомку
- Неизменяемые (read-only)
- Используются для передачи данных и callback-функций
State (состояние):
- Внутреннее состояние компонента
- Изменяемое через setState (классовые) или useState (функциональные)
- Локальное для каждого компонента
Правила:
- Не изменяйте props напрямую
- Обновляйте state только через специальные методы
- State должен быть минимально необходимым

3. Как работает поднятие состояния (lifting state up) и в каких ситуациях это необходимо?
Поднятие состояния - перемещение состояния в ближайшего общего родителя компонентов, которые нуждаются в общих данных.
Ситуации использования:
- Когда несколько компонентов должны отражать одни и те же данные
- Для синхронизации состояния между родственными компонентами
- Когда данные должны быть согласованными между разными компонентами
Пример: Два компонента фильтра, которые должны показывать согласованные данные

4. Какие методы жизненного цикла классовых компонентов вы знаете и для чего они используются?
Монтирование:
- constructor() - инициализация состояния и привязка методов
- render() - рендеринг компонента
- componentDidMount() - после монтирования в DOM, для API-запросов
Обновление:
- shouldComponentUpdate() - оптимизация, решение о ререндере
- render() - рендеринг обновленного компонента
- componentDidUpdate() - после обновления DOM
Размонтирование:
- componentWillUnmount() - очистка (таймеры, слушатели событий)

5. Как работают хуки useState и useEffect? Какие правила использования хуков существуют?
useState:
- Возвращает массив [state, setState]
- Позволяет добавлять состояние в функциональные компоненты
- setState может принимать функцию для обновления на основе предыдущего состояния
useEffect:
- Выполняет побочные эффекты в функциональных компонентах
- Заменяет componentDidMount, componentDidUpdate, componentWillUnmount
- Может иметь зависимости для контроля выполнения
Правила хуков:
- Вызывайте хуки только на верхнем уровне
- Вызывайте хуки только из React-функций
- Один хук - одна ответственность

6. Что такое ключи (keys) в React и почему они важны при рендеринге списков?
Keys - специальные строковые атрибуты, которые помогают React идентифицировать элементы в списке.
Важность:
- Помогают React определить, какие элементы изменились
- Дают элементам стабильную идентичность
- Улучшают производительность при обновлении списков
Правила:
- Keys должны быть уникальными среди siblings
- Лучше использовать стабильные ID из данных
- Избегайте индексов массива как keys при изменении порядка

7. Как обрабатывать события в React и чем это отличается от нативного JavaScript?
Отличия:
- В React события называются camelCase (onClick vs onclick)
- В JSX передается функция-обработчик, а не строка
- React использует синтетические события для кросс-браузерности
- Предотвращение поведения через preventDefault(), а не return false
Обработка:
<button onClick={handleClick}>Click</button>

8. Что такое управляемые и неуправляемые компоненты? В чем их разница?
Управляемые компоненты:
- Значение контролируется React через state
- Изменения обрабатываются через обработчики событий
- Единый источник истины
Неуправляемые компоненты:
- Значение хранится в DOM
- Доступ через refs
- Меньше кода, но сложнее контролировать
Когда использовать:
- Управляемые: для валидации, динамического управления
- Неуправляемые: для интеграции с не-React кодом, файловые input

9. Как работает контекст (Context) в React и когда его следует использовать?
Context предоставляет способ передачи данных через дерево компонентов без передачи props на каждом уровне.
Как работает:
- React.createContext() создает объект Context
- Context.Provider предоставляет значение для потомков
- Context.Consumer или useContext потребляют значение
Когда использовать:
- Глобальные данные (тема, пользователь, настройки)
- Когда props drilling становится слишком глубоким
- Для данных, которые нужны многим компонентам на разных уровнях

10. Какие преимущества предоставляют кастомные хуки и как создавать собственные хуки?
Преимущества:
- Переиспользование логики состояния между компонентами
- Разделение ответственности
- Более чистые и читаемые компоненты
- Легкое тестирование
Создание кастомных хуков:
- Функция, имя которой начинается с "use"
- Может использовать другие хуки
- Возвращает значения, которые могут использовать компоненты
Пример:
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    // логика получения из localStorage
  });
  
  useEffect(() => {
    // логика сохранения в localStorage
  }, [key, value]);
  
  return [value, setValue];
}